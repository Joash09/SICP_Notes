#+title: Chapter2

* Building Abstractions with Data

- Compound data -> Deal with data at a higher conceptual level than that of primitive data objects provided by the language
- Think of structs in C
- "Glue" code allows data objects to be combined into more complex structures
- "Closure" - glue code combines both primitive data and compound data
- Compound data acts as interface to combine program modules...?

- These principles lead to data-directed programming

* Data abstraction
- Programs should use data without making any assumptions about the data
- Consider language provided compound structure "pair"

 #+begin_src racket
#lang racket

(define x (cons 1 2))

(car x)
(cdr x)
 #+end_src

 #+RESULTS:
 : 1
 : 2

- Objects constructed from pairs are referred to as "list-structured" data

***  Exercise 2.1

#+begin_src racket :results output
#lang racket

(define (make-rat n d)
  (if (< d 0)
      (cons (- n) (- d))
      (cons n d)))

(make-rat 2 4)
(make-rat -2 4)
(make-rat 2 -4)
(make-rat -2 -4)
#+end_src

#+RESULTS:
: '(2 . 4)
: '(-2 . 4)
: '(-2 . 4)
: '(2 . 4)

** Abstraction Barriers

*** Exercise 2.2 and Exercise 2.3

#+begin_src racket
#lang racket

(define (point x y)
  (cons x y))

(define (x-point point)
  (car point))

(define (y-point point)
  (cdr point))

(define (make-segment p1 p2)
  (cons p1 p2))

(define (start-segment segment)
  (car segment))

(define (end-segment segment)
  (cdr segment))

(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))


(define p1 (point 0 0))
(define p2 (point 0 1))
(define p3 (point 1 1))
(define p4 (point 1 0))

(print-point p1)
(print-point p2)
(print-point p3)
(print-point p4)
(newline)

(make-segment p1 p2)
#+end_src

#+RESULTS:
:
: (0,0)
: (0,1)
: (1,1)
: (1,0)
: '((0 . 0) 0 . 1)

** What is meant by data

- It is not enough to say data is whatever is implemented with constructors and selectors (i.e. procedures)
  - maybe analogous to objects? however following lectures on lambda calculus it seems data can really be represented as pure functions as opposed to primitive data types in a language
  - See below
- Data must also include conditions that must be fulfilled in order to be a valid representation (analogous to business logic?)
- Any data can be represented by "Procedures + Conditions"
- Procedural representations of data is referred to "message passing" (central theme of object orientated programming)

- For example with the pair "data" structure z defined as (cons x y); the conditions are:
  - (car z) returns x
  - (cdr z) returns y
- The pair data structure is implemented with procedures
- We only use procedures to access pairs and therefore do not care about the implementation

- Extremely well made lecture on lambda calculus and how we can represent data as procedures (i.e. functions)
  - Part 1: https://www.youtube.com/watch?v=3VQ382QG-y4
  - Part 2: https://www.youtube.com/watch?v=pAnLQ9jwN-E

*** [[org:../SICP/LambdaCalculus.org][Deeper look into lambda calculus]]

*** Exercise 2.5



*** Exercise 2.6 (Church numerals: representing numbers as functions)

#+begin_src racket
#lang racket

; Seems to take argument f
(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))

(add-1 zero)
#+end_src

#+RESULTS:
: #<procedure:...aYz4s/ob-oiJAju.rkt:7:2>

** Extended exercise

Exercise 2.7 and 2.8

#+begin_src racket
#lang racket


(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (lower-bound y))))

(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (div-interval x y)
  (mul-interval x
                (if (or (= (upper-bound y) 0) (= (lower-bound y) 0))
                    (error "Cannot divide by zero")
                    (make-interval (/ 1.0 (upper-bound y))
                                   (/ 1.0 (lower-bound y))))))

; exercise 2.7
(define (make-interval a b)
  (cons a b))

(define (lower-bound z)
  (car z))

(define (upper-bound z)
  (cdr z))

; exercise 2.8
(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y))
                 (- (upper-bound x) (lower-bound y))))

; exercise 2.10
; see modified div-interval

; exercise 2.11

; exercise 2.12
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))

(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))

(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(define (make-center-percent c p)
  (make-center-width c (* c p)))

#+end_src

* Hierarchical Data and closure

- Closure: Result of a function taking parameters from set S results in an element also defined in S
- In Lisp, creating pairs whose elements are also pairs shows the importance of list structures
  - This is the "closure" property of procedure cons: Creating pairs within pairs

** Representing sequences

- Sequence: Ordered collection of data objects
- We can use pairs to create a sequence. First value in pair is the value at that index; and the second value in the pair is the next element in the sequence
- car therefore selects the first item (value)
- cdr therefore selects the rest of the sequence
- Lisp provides 'list' primitive to make this process easier

 #+begin_src racket
(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))

(list 1 2 3 4)

; append to the beginning of existing list
(cons 5 (list 1 2 3 4))
 #+end_src

- Conventional techniques for manipulating lists by "cdr'ing" down the list
- Because we cdr down a list often we can use null? primitive to know when the list is empty
- We can also 'cons' up
- See exercise 2.20 for dotted-tail notation

 #+begin_src racket
#lang racket

; get the element at index n - 1
; keep popping until n = 0
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))

(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))

(define (length-2 items)
  (define (length-iter a result)
    (if (null? a)
        result
        (length-iter (cdr a) (+ 1 result))))
  (length-iter items 0))

(define (append items1 items2)
  (if (null? items1)
      items2
      (cons (car items1) (append (cdr items1) items2))))

(define squares (list 1 4 9 16 25 36))
(define other-squares (list 49 64 81 100))

(list-ref squares 3)
(length squares)
(length-2 other-squares)
(append squares other-squares)
 #+end_src

 #+RESULTS:
 : 16
 : 6
 : 4
 : '(1 4 9 16 25 36 49 64 81 100)

*** Exercise 2.17

#+begin_src racket
#lang racket

(define (last-pair items)
  (if (null? (cdr items))
      items
      (last-pair (cdr items))))

(define squares (list 1 4 9 16 25 36))
(last-pair squares)

#+end_src

#+RESULTS:
| 36 |

*** Exercise 2.18

#+begin_src racket
#lang racket

(define (append items1 items2)
  (if (null? items1)
      items2
      (cons (car items1) (append (cdr items1) items2))))

(define (reverse items)
  (if (null? (cdr items))
      items
      (append (reverse (cdr items)) (list (car items)) )))

(define squares (list 1 4 9 16 25 36))
(reverse squares)
#+end_src

#+RESULTS:
| 36 | 25 | 16 | 9 | 4 | 1 |

*** Exercise 2.19

#+begin_src racket
#lang racket

(define us-coins (list 50 25 10 5 1))
(define us-coins-reversed (list 1 5 10 25 50))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))

(define (first-denomination items)
  (car items))

(define (except-first-denomination items)
  (cdr items))

(define (no-more? items)
  (null? items))

(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                   (first-denomination coin-values))
                coin-values)))))

(cc 100 us-coins)
(cc 100 us-coins-reversed)
#+end_src

#+RESULTS:
: 292
: 292

- Order does not matter

*** Exercise 2.20

- Dotted tail notation

#+begin_src racket
#lang racket

; Function same-parity takes at least one parameter
; . w used to represent the list of parameters with as type as x
(define (same-parity x . w)
  (cond (= (/ x 2) 0) () ; is even
        (else () )))

#+end_src

** Mapping over lists

- common pattern. Map takes function and list and pplies function on list
- map provides useful abstraction as now we don't care how the initial list as created/combined

*** Exercise 2.21

 #+begin_src racket
#lang racket

(define (square x) (* x x))

(define (square-list items)
  (if (null? items)
      null
      (cons (square (car items)) (square-list (cdr items)))))

(define (square-list-map items)
  (map square items))

(square-list (list 1 2 3 4))
(square-list-map (list 2 3 4))
 #+end_src

 #+RESULTS:
 | 1 | 4 | 9 | 16 |

*** Exercise 2.22


*** Exercise 2.23

#+begin_src racket
#lang racket

(define (for-each proc items)
  (if (null? items)
      null
      (cons (proc (car items)) (for-each proc (cdr items)))))

(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
#+end_src

#+RESULTS:
:
: 57
: 321
: 88'(#<void> #<void> #<void>)


** Hierarchical structures

- Use pairs to create trees
- Reminiscent of nodes with pointers to the same type as itself in C
- Use recursion to operate on the branches of a tree
- Length of tree produces: 1 + cdr of x
- Useful primiative 'pair?' provided for working with leaves

#+begin_src racket
#lang racket

(define x (cons (list 1 2) (list 3 4)))

(length x) ; 1 + (cdr x)

; consider car of list might itself have leaves
; when we reach leaves (not pairs) return 1
(define (count-leaves x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x)))) ))

(count-leaves x)
#+end_src

#+RESULTS:
: 3
: 4

*** Exercise 2.24

#+begin_src racket
#lang racket

(list 1 (list 2 (list 3 4)))

#+end_src

#+RESULTS:
| 1 | (2 (3 4)) |
 |     |
[1]  [2]  (3 4)
            | --- |
          [3]   [4]

*** Exercise 2.25

#+begin_src racket
#lang racket

(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))

(define a (list 1 3 (list 5 7) 9))

(list-ref (list-ref a 2) 1)

(define b (list (list 7)))
(car (car b))

(define c (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))
(cdr (cdr (cdr (cdr (cdr c)))))
#+end_src

#+RESULTS:
: 7
: 7

*** Exercise 2.28

*** Exercise 2.27

#+begin_src racket
#lang racket

(require racket/trace)

(define (append items1 items2)
  (if (null? items1)
      items2
      (cons (car items1) (append (cdr items1) items2))))

(define (deep-reverse x)
  (if (null? x)
      x
      (if (pair? (car x))
          (append (deep-reverse (cdr x)) (deep-reverse (car x)))
          (append (deep-reverse (cdr x)) (list (car x))))))

(define x (list (list 1 2) (list 3 4)))
(deep-reverse x)
#+end_src

#+RESULTS:
| 4 | 3 | 2 | 1 |

*** Exercise 2.28

#+begin_src racket
#lang racket

(require racket/trace)

; returns the leaves of a tree in a new sequence
(define (fringe items result)
  (if (not (pair? items)) ; if leaf element
      (append result (list items))
      (if (null? (cdr items))
          (fringe (car items) result)
          (fringe (cdr items) (fringe (car items) result)))))

(trace fringe)
(define x (list (list 1 2) (list 3 4)))
(fringe x '())
#+end_src

#+RESULTS:
#+begin_example
>(fringe '((1 2) (3 4)) '())
> (fringe '(1 2) '())
> >(fringe 1 '())
< <'(1)
> (fringe '(2) '(1))
> (fringe 2 '(1))
< '(1 2)
>(fringe '((3 4)) '(1 2))
>(fringe '(3 4) '(1 2))
> (fringe 3 '(1 2))
< '(1 2 3)
>(fringe '(4) '(1 2 3))
>(fringe 4 '(1 2 3))
<'(1 2 3 4)
'(1 2 3 4)
#+end_example

*** Exercise 2.29

#+begin_src racket
#lang racket

(define (make-mobile left right)
  (list left right))

(define (make-branch length structure)
  (list length structure))

(define (left-branch branch)
  (car branch))

(define (right-branch branch)
  (cdr branch))

(define (branch-length branch)
  (car branch))

(define (branch-structure branch)
  (cdr branch))

(define (total-weight mobile)
  (if (not (pair? mobile))
      (branch-structure mobile)
      (+ (total-weight (car mobile)) (total-weight (cdr mobile)))))
#+end_src

** Mapping over trees

- Example:

 #+begin_src racket
#lang racket

(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
 #+end_src

** Sequences and conventional interfaces

- Useful to think of algorithms as *signals*
- Same elements of filters and accumulators appear
- Key to organizing programs is to clearly represent the signal flow structure
- Represent signals as lists
- Modular design allows us to mix and match and change the order of operations applied to the "signal" within the system

 #+begin_src racket
#lang sicp

; if predicate is true return element with rest of filtered
; else return rest of the filtered items
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence)) (cons (car sequence)
                                          (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))

; apply operation on the first element with the rest of the list
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence) (accumulate op initial (cdr sequence)))))

(accumulate + 0 (list 1 2 3 4 5))

; add low to current list and rest of the elements to be added in interval
(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))

(enumerate-interval 2 7)

; return a list of elements part of a tree
; append the enumerated this part of the tree with the enumerated other part of the tree
(define (enumerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree)) ; return last element as a list
        (else (append (enumerate-tree (car tree)) (enumerate-tree (cdr tree))))))

(enumerate-tree (list 1 (list 2 (list 3 4)) 5))

;; signal flow diagrams
;; orignates from enumerate-tree passes to filter odd? then map to squares then accumulate
(define (sum-odd-square tree)
  (accumulate + 0 (map (lambda (x) (* x x)) (filter odd? (enumerate-tree tree)))))

(sum-odd-square (list 1 (list 2 (list 3 4)) 5))

 #+end_src

 #+RESULTS:
 | 2 | 3 | 4 | 5 | 6 | 7 |

*** Exercise 2.33

#+begin_src racket
#lang racket

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence) (accumulate op initial (cdr sequence)))))

(define (map p sequence)
  (accumulate (lambda (x y) (p x y)) null sequence))

(define (append seq1 seq2)
  (accumulate cons seq1 seq2))

(define (length sequence)
  (accumulate + 0 sequence))

#+end_src

*** Exercise 2.34: Horner's rule

#+begin_src racket
#lang racket

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence) (accumulate op initial (cdr sequence)))))

(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms)
                    (+ (* higher-terms x) this-coeff))
              0
              coefficient-sequence))

(horner-eval 2 (list 1 3 0 5 0 1))
#+end_src

#+RESULTS:
: 79

*** Exercise 2.35: Count leaves

#+begin_src racket
#lang racket

(require racket/trace)

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence) (accumulate op initial (cdr sequence)))))

(define (fringe items)
  (cond ((null? items) null)
        ((not (pair? items)) (list items))
        (else (append (fringe (car items))
                      (fringe (cdr items))))))

(define (count-leaves t)
  (accumulate +
              0
              (map (lambda (x) x) (fringe t))))
(trace count-leaves)

(count-leaves (list 1 2 (list 3 4)))
#+end_src

#+RESULTS:
: >(count-leaves '(1 2 (3 4)))
: <10
: 10

*** Exercise 2.36: Fold right function

#+begin_src racket

#lang racket

(require racket/trace)

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence) (accumulate op initial (cdr sequence)))))

; returns first item of each list
(define (first-items sequence)
  (if (null? sequence)
      null
      (append (list (car (car sequence))) (first-items (cdr sequence)))))

; returns rest of items from lists with first element removed
(define (get-rest sequence)
  (if (null? sequence)
      null
      (append (list (cdr (car sequence)))
              (get-rest (cdr sequence)))))

(define (accumulate-n op initial sequence)
  (if (null? (car sequence))
             null
             (cons (accumulate op initial (first-items sequence)) ; accumulate the first elements within the sequences
                   (accumulate-n op initial (get-rest sequence)))))

(define s (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
; (first-items s)
; (get-rest s)
(accumulate-n + 0 s)
#+end_src

#+RESULTS:
| 22 | 26 | 30 |

*** Exercise 2.37: Linear algebra, operations

#+begin_src racket
#lang racket

(require racket/trace)

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence) (accumulate op initial (cdr sequence)))))

; returns first item of each list
(define (first-items sequence)
  (if (null? sequence)
      null
      (append (list (car (car sequence))) (first-items (cdr sequence)))))

; returns rest of items from lists with first element removed
(define (get-rest sequence)
  (if (null? sequence)
      null
      (append (list (cdr (car sequence)))
              (get-rest (cdr sequence)))))
; modify from previous example; dont accumulate
(define (accumulate-n sequence)
  (if (null? (car sequence))
             null
             (cons (first-items sequence)
                   (accumulate-n (get-rest sequence)))))

(define (dot-product v w)
  (accumulate + 0 (map * v w)))

; ===============================================================================

; m x n time n x 1 matrix = m x 1
; how I solved originally
(define (matrix-*-vector m v)
  (define (dot-product-iter row)
    (if (null? row)
        null
        (append (list (dot-product (car row) v)) (dot-product-iter (cdr row)))))
  (dot-product-iter m))
(trace matrix-*-vector)

(define (transpose mat)
  (accumulate-n mat))

(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map matrix-*-vector m (car cols))))

; 3 x 3
(define m (list (list 1 2 3) (list 4 5 6) (list 7 8 9)))
; (transpose m)

; 3 x 1
(define v (list 4 5 6))

; 3 x 3 times 3 x 1
(matrix-*-vector m v)
(transpose m)
#+end_src

#+RESULTS:
| 4 |
| 5 |
| 6 |

*** Exercise 2.38: Fold algorithms

- foldleft: (((...) + a) + a) + a
- foldright: a + (a + (a + (...)))

#+begin_src racket
#lang racket

(require racket/trace)

(define (fold-right op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op (car rest) result)
              (cdr rest))))
  (iter initial sequence))
(trace fold-right)

(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
(trace fold-left)

(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list null (list 1 2 3))
(fold-left list null (list 1 2 3))

; operators that have the commutative property can work for fold-left and fold-right algorithms
#+end_src

#+RESULTS:
#+begin_example
>(fold-right #<procedure:/> 1 '(1 2 3))
<3/2
3/2
>(fold-left #<procedure:/> 1 '(1 2 3))
<1/6
1/6
>(fold-right #<procedure:list> '() '(1 2 3))
<'(3 (2 (1 ())))
'(3 (2 (1 ())))
>(fold-left #<procedure:list> '() '(1 2 3))
<'(((() 1) 2) 3)
'(((() 1) 2) 3)
#+end_example

*** Exercise 2.39: Reverse with fold
#+begin_src racket
#lang racket

; foldright: a + (a + (a + (...)))
; 4 + ( 1 2 3 ) => 4 + 3 + (1 2) => 4 + 3 + 2 + (1)
(define (fold-right op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op (car rest) result)
              (cdr rest))))
  (iter initial sequence))

(define (reverse-right sequence)
  (fold-right (lambda (x y)
                (cons x y))
             null
             sequence))

; foldleft: (((...) + a) + a) + a
; ( 1 2 3 4 ) => (2 3 4) + 1 => ( 3 4 ) + 2 + 1 => 4 + 3 + 2 + 1
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))

(define (reverse-left sequence)
  (fold-left (lambda (x y)
               (cons y x))
             null
             sequence))

(display (reverse-right (list 1 2 3 4)))
(newline)
(display (reverse-left (list 1 2 3 4)))

#+end_src

#+RESULTS:
| 4 | 3 | 2 | 1 |

** Sequence Operations and Mappings

- Express sequence paradigm for computations that are commonly use nested loops
- map + accumulate function is popular enough to define flatmap

 #+begin_src racket
#lang sicp

; taken from above
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence) (accumulate op initial (cdr sequence)))))
(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))

(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence)) (cons (car sequence)
                                          (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))

;; Generate sequence of pairs <= n
(define n 5)
(accumulate append
            nil
            (map (lambda (i)
                   (map (lambda (j) (list i j)
                        (enumerate-interval 1 (- i 1)))))
                 (enumerate-interval 1 n)))

; map + accumulate function is popular enough to define flatmap
;; (define (flatmap proc seq)
;;   (accumulate append nil (map proc seq)))

; recursively generate permutations of S - x
;; (define (permutations s)
;;   (if (null? s)
;;       (list nil)
;;       (flatmap (lambda (x)
;;                  (map (lambda (p) (cons x p))
;;                       (permutations (remove x s))))
;;                s)))

; filter all items aren't equal to x
(define (remove item sequence)
  (filter (lambda (x) (not (= x item))) sequence))
 #+end_src

 #+RESULTS:
 : 15
 : (2 3 4 5 6 7)
 : (1 2 3 4 5)
 : 35


*** Exercise 2.40: Unique pairs
#+begin_src racket
#lang sicp

(define (enumerate low high)
  (if (> low high)
      nil
      (cons low (enumerate (+ low 1) high))))
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence)) (cons (car sequence)
                                          (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))

; succesive pairs up to and incl. n
(define (unique-pairs n)
  (map (lambda (i) (list (- i 1) i))
       (filter even? (enumerate 1 n))))

(unique-pairs 5)
(unique-pairs 10)
#+end_src

#+RESULTS:
: ((1 2) (3 4))
: ((1 2) (3 4) (5 6) (7 8) (9 10))

*** Exercise 2.41: ordered triplets
#+begin_src racket
#lang sicp
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence) (accumulate + 0 (cdr sequence)))))
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence)) (cons (car sequence)
                                          (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
(define (enumerate low high)
  (if (> low high)
      nil
      (cons low (enumerate (+ low 1) high))))

; enumerate from 0 to (n-2) -> map element + next 2 (inner loop from current index to index + 2) -> sum -> filter where sum >= s -> accumulate
(define (ordered-triplets n s)
              (filter (lambda (i) (<= i s))
                      (map (lambda (j) (accumulate + 0 (enumerate j (+ j 2))))
                           (enumerate 0 (- n 2)))))

(ordered-triplets 8 15)
#+end_src

#+RESULTS:
: (3 6 9 12 15)

* Symbolic Data

- Working data that wasn't constructed with numbers
- Use quotation

** Quotation

- Quotes only go at the beginning of the object
  - (list 'a 'b)
  - (car '(a b c))

*** Exercise 2.53

1. a b c
2. ((george))

*** Exercise 2.54

#+begin_src racket
#lang racket

(define (equal? a b)
  (cond (not (eq? a b)) #f
        (null? a) #t
        (and (cdr a) (cdr b) )))

#+end_src

*** Exercise 2.55

First quote creates list with second <quote> and abracadabra; hence car of the list returns the second quote

** Symbolic differentiation

- Symbolic differentiation is one of the motivating reasons in the development of Lisp
- Lets assume the following reduction rules:
  - dc/dx = 0; for c a constant
  - dx/dx = 1
  - d(u + v) / dx = du/dx + dv/dx
  - d(uv) / dx = u * (dv/dx) + v * (du/dx) "Chain rule"
- Last two rules are recursive

- Main algorithm is to decompose expression in symbols (e.g. number, variable, sum etc.) and perform corresponding differentiation techniques accordingly
- Need to define procedures for evaluating symbols and their corresponding actions
- Primitive symbol? allows us to test if expression is a symbol (quoted data)

*** Exercise 2.56 and 2.57 are included in code snippet below

#+begin_src racket
#lang racket

(define (variable? x) (symbol? x))

; Check is v1 and v2 are symbols; then check if equal
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (=number? expr num)
  (and (number? expr) (= expr num)))

(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2) ; simplify expression
        ((=number? a2 0) a1) ; simplify expression
        ((and (number? a1) (number? a2))
         (+ a1 a2)); can be returned as a single number
        (else (list '+ a1 a2)))) ; else return as quoted expression

(define (make-product a1 a2)
  (cond ((or (=number? a1 0) (=number? a2 0)) 0)
        ((=number? a1 1) a2)
        ((=number? a2 1) a1)
        ((and (number? a1) (number? a2)) (* a1 a2))
        (else (list '* a1 a2))))

(define (sum? x)
  (and (pair? x) (eq? (car x) '+))) ; check if pair; then see if 1st element is +

(define (product? x)
  (and (pair? x) (eq? (car x) '*)))

(define (addend s) (cadr s)) ; get 2nd item of sum list (expression)

(define (augend s) (caddr s)) ; get 3rd item of sum list (expression)

(define (multiplier s) (cadr s)) ; get 2nd item of product list (expression)

(define (multiplicand s) (caddr s)) ; get 3rd item of product list (expression)

(define (exponent? s)
  (and (pair? s) (eq? (car s) '**)))
(define (base s) (cadr s))
(define (exponent s) (caddr s))
(define (make-exponent base expo)
  (cond ((=number? expo 0) 1)
        ((=number? expo 1) base)
        (else (list '** base expo))))

; The derivative algorithm
(define (deriv expr var)
  (cond ((number? expr) 0) ; deriv of constant = 0
        ((variable? expr)
         (if (same-variable? expr var) 1 0)) ; if expr. and var. same return 1
        ((sum? expr) ; deriv ( u + v ) = deriv (u) + deriv (v)
         (make-sum (deriv (addend expr) var)
                   (deriv (augend expr) var)))
        ((product? expr) ; chain rule
         (make-sum (make-product (multiplier expr)
                                 (deriv (multiplicand expr) var))
                   (make-product (deriv (multiplier expr) var)
                                 (multiplicand expr))))
        ((exponent? expr) ; product rule
         (make-product (exponent expr)
                       (make-exponent (base expr)
                                      (make-sum (exponent expr) -1))))
        (else
         (error "unknown exprression type" exp))))

; (sum? '(+ x 3))
; (same-variable? (addend '(+ x 3)) 'x)
; (addend '(+ 3 3))
(display (deriv '(+ x 3) 'x))
(newline)
(display (deriv '(* x y) 'x))
(newline)
(display (deriv '(** x 3) 'x))
#+end_src

#+RESULTS:
: 1
: y
: (* 3 (** x 2))

** Representing sets

- Previously reducing expressions could be either done at construction time or selection time
- A set is a collection of distinct objects
- As "data" (previously discussed) sets require procedures to be used on the sets
  - union-set
  - intersection-set
  - element-of-set?
  - adjoin-set
- Given we have discussed procedures we can now start with the implementation
- Section shows how to create different solutions for the same problem by using different data structures

*** Sets as unordered list

- Exercise 2.59 included in snippet

 #+begin_src racket
#lang racket

(require racket/trace)
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))

; returns set of original set + adjoined element
(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1) (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))

; exercise 2.59
; return both set1 and set2
(define (union-set set1 set2)
  (if (null? set1)
      set2
      (union-set (cdr set1) (adjoin-set (car set1) set2))))
(trace union-set)

(define A '(1 2 3 4))
(define B '(4 5 6 7))
; (display (adjoin-set 5 A))
; (newline)
; (display (intersection-set A B))
; (newline)
(display (union-set A B))
 #+end_src

 #+RESULTS:
 : >(union-set '(1 2 3 4) '(4 5 6 7))
 : >(union-set '(2 3 4) '(1 4 5 6 7))
 : >(union-set '(3 4) '(2 1 4 5 6 7))
 : >(union-set '(4) '(3 2 1 4 5 6 7))
 : >(union-set '() '(3 2 1 4 5 6 7))
 : <'(3 2 1 4 5 6 7)
 : (3 2 1 4 5 6 7)

*** Exercise 2.60: Allow duplicates within sets
#+begin_src racket
#lang racket


#+end_src

*** Sets as ordered lists


- Making the assumption that the list will only contain numbers
- See example below
- Gives performance benefits; e.g. do not need to scan the entire list
  - Element-of-set: scanning half the list still is O(n) growth but saves as a factor of 2
  - Intersection-set: O(n) instead of O(n^2); for each element in set1 we are not comparing for each item in set2

**** Exercise 2.61 and 2.62

#+begin_src racket
#lang racket

(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) true)
        ((< x (car set)) false) ; ordered so give up
        (else (element-of-set? x (cdr set)))))

(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      '()
      (let ((x1 (car set1)) ; set x1 and x2 to first elements in the two sets
            (x2 (car set2)))
        (cond
          ; if intersect find intersect with rest of both set1 and set2
          ((= x1 x2) (cons x1 (intersection-set (cdr set1) (cdr set2))))
          ; if x1 < x2, we can remove x1 and carry on
          ((< x1 x2) (intersection-set (cdr set1) set2))
          ; similarly if x2 < x1; ignore x2 and carry on
          ((< x2 x1) (intersection-set set1 (cdr set2)))))))

(define (adjoin-set x set) ; element must be inserted in order
  (cond ((null? set) x) ; no set to join with
        ((> x (car set)) ; too big to be inserted here
         (cons (car set) (adjoin-set x (cdr set)))); prev elements + inserted set
        (else (cons x set))))

(require racket/trace)
(define (union-set set1 set2) ; return both sets in order
  (if (null? set1)
      '()
      (adjoin-set (car set1) (union-set (cdr set1) set2))))
(trace union-set)

(adjoin-set 5 (list 3 4 6 7))
(adjoin-set 8 (list 3 4 6 7))
(union-set (list 11 13 15) (list 8 9 15))
#+end_src

#+RESULTS:
: (3 4 5 6 7)
: (3 4 6 7 . 8)

*** Sets as binary trees

- Halving the size of the problem is distinguishing characteristic of logarithmic growth
  - remember fast-exponentiation

**** Includes Exercise 2.65
#+begin_src racket
#lang sicp

(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))

;; compare to first element in tree;
;; if less only search left else only search right
(define (element-of-set? x set)
  (cond ((null? set) false) ; cannot find element
        ((= x (entry set)) true)
        ((< x (entry set)) (element-of-set? x (left-branch set)))
        ((> x (entry set)) (element-of-set? x (right-branch set)))))

;; similarly for adjoin
(define (adjoin x set)
  (cond ((null? set) (make-tree '() '()))
        ((= x (entry set)) set)
        ((< x (entry set)) (make-tree (entry set)
                                      (adjoin x (left-branch set))
                                      (right-branch set)))
        ((> x (entry set)) (make-tree (entry set)
                                      (left-branch set)
                                      (adjoin x (right-branch set))))))

#+end_src

#+RESULTS:


*** Huffman encoding example

- fixed length codes: each symbol represented has the same number of bits
- similar to Morse code( variable length ), it would be more efficient to represent commonly used symbols shorter number of bits
- variable length makes it harder to determine when one symbol ends and the other begins

- Huffman encoding is such a variable length encoding scheme
- represented as a binary tree; symbols sit within the leaves
- each symbol is assigned a weight corresponding to relative frequency
- start at root, move down tree and add 0 or 1 depending if moving right or left until reaching leaf representing symbol. Then start at root again for next symbol

#+begin_src racket
#lang sicp

; represent the Huffman tree
; attach "leaf" tag to symbol and weight
(define (make-leaf symbol weight) (list 'leaf symbol weight))
(define (leaf? object) (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))

;; defining general tree
(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))

(define (left-branch tree) (car tree))
(define (right-branch tree) (cdr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))

;; decoding procedure
(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit" bit))))

(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch) (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
#+end_src

* Multiple Representations for Abstract Data

- Covered:
  - Abstraction
  - Structuring data
- Goals for programs is to have "abstraction barriers"
  - Abstraction barrier: Isolate the underlying representation of the data objects
  - Consider the case for multiple representations for data
- This chapter deals with how to handle multiple representations for data
  - This is accomplished through generic procedures which can manage different representations of data
  - The main technique for this is to have *type tags*
- Also discuss *data-directed* programming: strategy for assembling systems with generic procedures

*** Representations for complex numbers with tagged data

- Discipline of attaching and stripping off tags is important organizational discipline
- Consider two different representations for complex numbers: rectangular and polar co-ordianates
  - 2 different ways to get the real and imaginary parts of the complex number; depending if it is in rectangular form or polar form
  - similarly 2 different ways to get the magnitude and angle from a complex number depending on its representation

#+begin_src racket
#lang sicp

;; 2 different ways of representing complex numbers
(make-from-real-img (real-part z) (imag-part z)) ; rectangular
(make-from-mag-ang (magnitude z) (angle z)) ; polar

;; different representations of complex numbers means different implementations of extracting information from the data
;; Rectangular implementation
(define (real-part z) (car z))
(define (imag-part z) (cdr z))
(define (magnitude z)
  (sqrt (+ (square (real-part z))
           (square (imag-part z)))))
(define (angle z)
  (atan (imag-part z) (real-part z)))
(define (make-from-real-imag x y) (cons x y))
(define (make-from-mag-ang r a)
  (cons (* r (cos a)) (* r (sin a))))

;; Polar representation
(define (real-part z) (* (magnitude z) (cos (angle z))))
(define (imag-part z) (* (magnitude z) (sin (angle z))))
(define (magnitude z) (car z))
(define (angle z) (cdr z))
(define (make-from-real-imag x y)
  (cons (sqrt (+ (square x) (square y)))
        (atan y x)))
(define (make-from-mag-ang r a) (cons r a))

;; general procedures for complex number arithmetic
(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
(define (sub-complex z1 z2)
  (make-from-real-imag (- (real-part z1) (real-part z2))
                       (- (imag-part z1) (imag-part z2))))
(define (mul-complex z1 z2)
  (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                     (+ (angle z1) (angle z2))))
(define (div-complex z1 z2)
  (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                     (- (angle z1) (angle z2))))

#+end_src

- Mechanism for tagging data
- Will need differentiate between the procedures of the 2 implementations
- Then define general procedures which call the corresponding implementation based off tag

#+begin_src racket
#lang sicp

; define tag datum with ordinary list structure with helper methods
(define (attach-tag type-tag contents)
  (cons type-tag contents))
(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum: TYPE_TAG" datum)))
(define (contents datum)
  (if (pair datum)
      (cdr (datum))
      (error "Bad tagged datum: CONTENTS" datum)))

(define (rectangular? z) (eq? (type-tag z) 'rectangular))
(define (polar? z) (eq? (type-tag z) 'polar))

; rewrite implementation procedures
; rectangular
(define (real-part-rectangular z) (car z))
(define (img-part-rectangular z) (cdr z))

; polar
(define (real-part-polar z) (* (magnitude z) (cos (angle z))))
(define (img-part-polar z) (* (magnitude z) (sin (angle z))))
(define (magnitude z) (car z))
(define (angle z) (cdr z))

; general methods
(define (real-part x)
  (cond ((rectangular? x) (real-part-rectangular x))
        ((polar? x) (real-part-polar x))
        (else (error "Unknown type"))))

; (define (img-part x) ...
#+end_src

*** Data-directed programming and Additivity

- Dispaching on type: process of checking tag and calling corresponding procedure
- Problems with dispatching:
  - generic interfaces must know of all implementations
  - Need to make sure procedure names for different implementations do not overlap
  - These problems mean dispatching is not *additive*

- Solution is use data-directed programming

- Create table:
  - Possible operations y axis
  - Possible types x axis
- Algorithm looks up combination of operation and type

- Implementation:
  - put and get commands for manipulating table
  - implement package with:
    - internal procedures
    - way to iterface with the rest of the system
  - define "apply-generic" procedure
  - "register" generics

#+begin_src racket
#lang sicp

;; define package
(define (install-rectangular-package)

  ;; procedures for this package
  ;; don't to worry if names are unique compared to other packages
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (* r (cos a)) (* r (sin a))))

  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; polar package would be similar


;; generic procedure which applies package based on operation and type required
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (error "No method for these types: APPLY-GENERIC"
                 (list op type-tags))))))

;; apply generics as follows
(define (real-part z) (apply-generic 'real-part z))
(define (imag-part z) (apply-generic 'imag-part z))

(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'rectangular) x y))
#+end_src


* Systems with Generic Operations

- Previous section showed how to design systems with data structured in different ways (i.e. unordered lists, ordered lists, trees etc. )
