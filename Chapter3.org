#+title: Chapter 3: Modularity, Objects and State
#+author: Joash Naidoo

- Really 2 prominent organizational strategies for programs:
  1. Concentrating on objects and how their behaviours change over time
    - Substitution model is not appropriate and will be replaced with *environment model* of computation
  2. Concentrating on streams like in signal processing systems
    - Will be discussing *delayed evaluation* model of computation

* Assignment and Local State

- Objects have a state if it changes over time
- Can alter the vale of the defined variable with *set!* (implementation dependant)
  - procedures which end with ! by convention change value of variable
- With *begin* keyword we can group and evaluate expressions part of a sequence

- Following code procedure shows how to create an "environment" for which only that procedure can modify the value of balance
- Substitution model of evaluation doesn't work here; i.e. can't substitute 100 for balance everytime as the code suggests
- Each call to make-withdraw defines procedures associated with balance. Dispatch takes a tag and returns corresponding method: *message-passing* programming

 #+begin_src racket
#lang sicp

; same as new-withdraw but now we set balance before-hand
(define (make-account balance)
  (define (widthdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount)) balance)
        "Insuffient funds"))

  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)

  (define (dispatch m)
    (cond ((eq? m 'widthdraw) widthdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown tag:" m))))

  dispatch) ; everytime make-account is called; call dispatch

(define W1 (make-account 100)) ; associating make-account procedure with variable W1
(define W2 (make-account 100))
((W1 'widthdraw) 3) ; calling make-account which in turn calls dispatch
((W2 'deposit) 50) ; calling make-account which in turn calls dispatch
 #+end_src

 #+RESULTS:
 : 97
 : 150

*** Exercise 3.1
#+begin_src racket
#lang sicp

(define (make-accumulator sum)
  (lambda (inc)
    (set! sum (+ sum inc))
    sum))

(define S1 (make-accumulator 10))
(define S2 (make-accumulator 10))
(S1 10)
(S1 10)
(S2 5)
#+end_src

#+RESULTS:
: 20
: 30
: 15

*** Exercise 3.2
#+begin_src racket
#lang sicp

(define (make-monitored func) ; procedure which takes function

  (let ((count 0)) ; set internal count variable

    (define (apply-procedure amount)
      (set! count (+ count 1)) ; inc everytime make-monitored called
      (func amount))

    (define (dispatch m)
      (cond ((eq? m 'how-many-calls?) count)
            ((eq? m 'reset) (begin (set! count 0) count))
            (else (apply-procedure m))))

    dispatch))

(define s (make-monitored sqrt))
(s 100)
(s 'how-many-calls?)
(s 100)
(s 'how-many-calls?)
(s 'reset)
#+end_src

#+RESULTS:
: 10
: 1
: 10
: 2
: 0

*** Exercise 3.3 and 3.4
#+begin_src racket
#lang sicp

(define (make-account balance password)

  (let ((incorrect-count 0))

    (define (widthdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insuffient funds"))

    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)

    (define (dispatch p m)
      (cond ((> incorrect-count 7) (error "Calling the cops"))
            ((not (eq? p password))
             (begin (set! incorrect-count (+ incorrect-count 1))
                    (error "Incorrect password")))
            ((eq? m 'widthdraw) widthdraw)
            ((eq? m 'deposit) deposit)
            (else (error "Unknown tag:" m))))

    dispatch))

(define acc (make-account 100 'secret-password))

((acc 'secret-password 'widthdraw) 40)
((acc 'secret-password 'deposit) 40)
((acc 'another-password 'deposit) 40)
#+end_src

** Benefits of assignment

- Viewing systems as objects with states can lead to modular design
- Great for modelling computational objects whose state changes over time

** Cost of Introducing assignment

- No longer use substitution model of evaluation
- No evaluation model with "nice" mathematical properties
- With assignments we cannot be sure a procedure with the same arguments to the same function will produce the same result
- Programming with no assignments is referred to as *functional* programming
- With state, variables are no longer just names for value

- Cannot determine "change" without some a priori notion of "sameness"

- Imperative programming: making extensive use of assignments
- Bugs susceptible to imperative programs and not functional ones:
  - Order of assignments becomes very important
  - This is worse when executing concurrent programs
- Imperative programs not more performant than calling procedures
- May be easier to start with functional programming over imperative; as being concerned with the order of assignments detract from important concepts

*** Exercise 3.7
#+begin_src racket
#lang sicp

#+end_src

*** Exercise 3.8
#+begin_src racket
#lang sicp

(define (make-function x)
        (lambda (y) (begin (set! x (* x y))
                           x)))

; order of evaluation of subexpressions matter with assigment
(define f (make-function -1))
(+ (f 0) (f 1))
(define s (make-function -1))
(+ (s 1) (s 0))
#+end_src

#+RESULTS:
: 0
: -1

* The Environment Model of Evaluation

- Environments are made up of a sequence of frames
- Frame: a table of *bindings* which associate variable names with values
  - each frame (except the global environment) has a pointer to enclosing environment. We can think of this as a stack of frames. If a variable name is not found in the current frame, move up frames until it is found
  - value of variable w.r.t environment is given by first frame in environment with a binding to that variable
  - if no frame has a binding to that variable; the variable is unbound
  - Top level frame is our *global environment*. It has no enclosing environments
  - frame may be shared across multiple environments

- Expressions are meaningless without respect to an environment. e.g (+ 1 1) the symbol + only means addition in an environment which defines addition (has an inherited context)

** Rules for evaluation

- Shift in viewpoint from substitution model:
  - variables not name for value but box in which we can store things
  - procedures not mathematical functions but object with inherited context

- Procedures created by evaluating a lambda expression (see. below)
- "define" creates definitions by adding bindings to frames
#+begin_src racket
(define (square x) (* x x))
; is the same as
(define square (lambda (x) (* x x)))
#+end_src
- A procedure created by lambda expression relative to a given environment. Resulting procedure consists of "double bubble" (i.e. code in lambda expression and pointer to environment in which it was created)

- Procedure is an object applied to set of arguments by constructing a frame
  Binding the formal parameters of the procedure to the arguments of the call

- Evaluating the body of the procedure results in the creation of a new environment (i.e. sequence of frames).

- The new frame has (points to) the enclosing environment of the environment for which procedure object is being applied


- "defining" symbol creates binding in current environment frame
- "set!" first locates the first frame with binding of the variable in the environment and changes binding to represent the new value
  - if variable unbound (i.e. no environment frame binding) it will throw an error

- We use this model for building an interpreter later

** Applying simple procedures
#+begin_src racket
#lang sicp

(define (square x) (* x x))
(define (sum-of-squares x y) (+ (square x) (square y)))
(define (f a) (sum-of-squares (+ a 1) (* a 2)))

;; global environment has bindings to lambda expressions square, sum-of-squares and f

(f 5)
;; evaluating a procedure creates new environment (e.g. E1) (points to global)
;; need to evaluate subexpressions
;; from E1 (no binding for sum-of-squares found) we move up to global environment
;; (+ a 1) and (* a 2) subexpression evaluated -> 6 and 10
;; applying 6 and 10 to proedure sum-of-squares results in new environment (e.g. E2) (points to global)
;; now evaluate subexpressions
;; find square in global frame
;; evaluate first square subexpression results in E3 (points to global)
;; evaluate second square subexpression results in E4 (points to global)
;; because we are setting up different environments for each procedure call; we can keep different bindings for variables names resued (e.g. x)
#+end_src

*** Exercise 3.9
#+begin_src racket
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))

;; global environment has bindings to lambda expression factorial
(factorial 6)
;; evaluate new procedure results in new environment E1
;; create binding in frame: n = 6
;; evaluate subexpression (* n (factorial (- n 1)))
;; n -> 6 and (- n 1) -> 5
;; evaluate (factorial 5) results in new environment E2 points to E1 (not global)
;; create binding in E2: n = 6
;; evaluate subexpression (* n (factorial (- n 1)))
;; n -> 5 and (- n 1) -> 4
;; evaluate (factorial 4) results in new environment E3 points to E2
;; ...
#+end_src

#+begin_src racket
#lang sicp
(define (factorial n) (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product) (+ counter 1) (max-count))))
;; global environment has bindings for factorial and fact-iter
(factorial 6)
;; evaluating (factorial 6) creates new environment E1
;; evaluate (fact-iter 6) creates new environment E2 points to E1
;; move up to global environment to find binding for (fact-iter)
#+end_src

- Replacing substitution model with environment model does not sort out issue of tail end recursion using constant memory space. (That is addressed again in Chapter 5)

** Frames as the Repository of Local State

How did this code work?

#+begin_src racket
#lang sicp

(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insuffient funds")))
;; create binding for make-withdraw in global environment
(define W1 (make-withdraw 100))
;; evaluate make-withdraw resulting in creating environment E1 which binds balance to 100
;; lambda is evaluated resulting procedure object (double bubble pointing to code and E1) which is then bound to W1 in the global environment
(W1 50)
;; Now we can create frame where 50 is bound to amount (parameter of lambda)
;; this frame is enclosed by E1 (NOT global environment) because this is the environment specified by the W1 procedure object (double bubble pointing to E1)
;; amount found in first frame; whilst balance is found one frame above
(define W2 (make-withdraw 100))
;; evaluate make-withdraw resulting in new environment E2 and bind balance in new frame to 100
;; bind procedure object (double bubble pointing code to E2) resulting from lambda to W2 in global environment
;; thus W1 and W2 act as separate objects
#+end_src

- multiple instances of procedure objects (double bubble) may share the code body or keep a separate copy of the code. Up to interpreter implementation to decide

***  Exercise 3.10

- Remember (let ((<var> <exp>)) <body>) is syntactic sugar for ((lambda (<var>) <body>) <exp>)
 #+begin_src racket
#lang sicp

(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insuffient funds"))))
 #+end_src

** Internal Definitions
#+begin_src racket
#lang sicp

;; procedure with internal definitions
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))

;; sqrt bound to global environment
(sqrt 2)
;; sqrt called; new environment E1 created
;; E1 binds parameter x to 2
;; symbol good-enough added to E1 with procedure object (double bubble) pointing back to E1
;; similarily for improve and sqrt-iter
;; expression sqrt-iter evaluated forming environment E2 pointing to E1
;; E2 binds guess to 1.0
;; evaluating good-enough? in sqrt-iter forms E3 pointing to E1 and creates new binding in E3 guess to 1.0
;; notice sqrt-iter and good-enough? guess parameters are separated
;;
#+end_src

- internal procedure evaluations create environments which point to the environment created the enclosing procedure's call

- internal definitions are a useful technique for modularizing programs because:
  - names of local procedures don't interfer with external procedures
  - local procedures can access arguments of the enclosing procedure as free variables

*** Exercise 3.11
#+begin_src racket
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else
           (error "Unknown request: MAKE-ACCOUNT"
                  m))))
  dispatch)
;; define make-account binding in global environment

(define acc (make-account 50))
;; evaluate make-account creating environment E1, double bubble procedure object which points to global environment
;; widthdraw, deposit and dispatch bindings added to E1 (internal definitions)
;; in E1 bind balance to 50
;; make binding acc in global environment

((acc 'deposit) 40)
;; evaluate (acc 'deposit) by creating environment E2 which points to

((acc 'withdraw) 60)
#+end_src

* Modeling with Mutable Data

- What happens when compound objects with mutable data?
- Mutators: operations which modify data objects
- Chapter 2 we used pairs to model complex objects (i.e. lists, trees ...)
- Similarly we'll look at mutable pairs

** Mutable List Structure

- Primitives set-car! and set-cdr! are available to us
- set-car! takes 2 parameters: existing pair pointer and pointer which will replace
- set-cdr! takes 2 parameters: existing pair pointer and pair which will be added on
- return values are dependent on implementation

- consider the case set-car! replaces pair pointer with another; the original is now garbage. Lisp has a *garbage collector* which recycles the memory used by this now replaced pair pointer

- We can define cons in terms of the two mutators
 #+begin_src racket
#lang sicp

(define (cons x y)
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
 #+end_src

*** Exercise 3.12

#+begin_src racket
#lang sicp
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))
(cdr x) ;; expecting b
(define w (append! x y))
(cdr x) ;; expecting ('b 'c 'd)
#+end_src

#+RESULTS:
: (b)
: (b c d)

*** Exercise 3.13

#+begin_src racket
;; DONT RUN THIS
#lang sicp
(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
(define z (make-cycle (list 'a 'b 'c))) ; last pair |'c | null | -> |'c | 'a |
(last-pair z) ;; creates forever loop
#+end_src

*** Exercise 3.14

#+begin_src racket
#lang sicp
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
#+end_src

*** Sharing and Identity

- different structures can be composed of shared pairs
- this is only significant when dealing with mutators
- use eq? primitive to check if same pointers (i.e. same object)
- beware unexpected results with mutation

*** Mutation is just assignment

- Previously shown that pairs are represented with just procedures (functions)
 #+begin_src racket
#lang sicp
(define (cons x y)
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          (else (error "Undefined operation: CONS" m))))
  dispatch)
 #+end_src
- We can do something similar with mutable data
 #+begin_src racket
#lang sicp
(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else (error "Undefined operation: CONS" m))))
  dispatch)
 #+end_src
- Assignment requires us to modify environment which itself is a mutable data structure

** Representing Queues

- cons, car and cdr cannot represent queues on their own
- queue: FIFO data structure

- typically adding to the end means scanning the queue to find end
  - inefficient O(n)
- instead have queue structure also contains a pointer to the last pair
  - inserting now O(1)

- Queue = front and rear pointers

#+begin_src racket
#lang sicp

;; Queue implementation
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item)
  (set-car! queue item))
(define (set-rear-ptr! queue item)
  (set-cdr! queue item))

(define (empty-queue? queue)
  (null? (front-ptr queue)))

(define (make-queue)
  (cons '() '()))

(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue")
      (car (front-ptr queue))))

(define (insert-queue! queue item)
  (let ((new-pair (cons item '()))) ; define new item as a pair
    (cond ((empty-queue? queue) ; if empty set first and last pointer to new item
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else (set-cdr! (rear-ptr queue) new-pair) ; else add item to the rear
                (set-rear-ptr! queue new-pair) ; update rear-ptr to new item
                queue))))

(define (delete-queue! queue)
  ((cond ((empty-queue? queue)
          (error "Cannot delete empty queue"))
         (else (set-front-ptr! queue (cdr (front-ptr queue))) ; only need to update first element
               ; no need to update rear-ptr since we only look at front-ptr to evaluate if queue is empty
               queue))))
#+end_src

** Representing Tables

- Keep record of records with identifying keys
- *headed list*: tables are constructed with a backbone pair which hold dummy key-value pairs
  - car points to the key-value pair
  - cdr points to the next "backbone" pair
- lookup defined by *assoc* operation

- will be useful for meta-circular evaluator

 #+begin_src racket
#lang sicp

;; recursively search records and return value
(define (assoc key records)
  (cond ((null? records) false)
        ((equal? key (caar records)) (car records)) ; if key equal to key in key-value pair, return "backbone" pair
        (else (assoc key (cdr records)))))

(define (lookup key table)
  (let ((record (assoc key (cdr table)))) ; get key-value pair
    (if record
        (cdr record) ; return value in key-value pair
        false)))

(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value) ; update value at key if exists
        (set-cdr! table (cons (cons key value) (cdr table))))) ; else create key-value pair linked to "backbone" pair connected to the rest of table
  'ok)

(define (make-table) (list '*table))
 #+end_src

 #+RESULTS:

*** 2D tables

- 2 keys index each value
- effectively have 2 "backbone" chains

 #+begin_src racket
#lang sicp

(define (assoc key records)
  (cond ((null? records) false)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))

(define (lookup key-1 key-2 table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              false))
        false)))

(define (insert! key-1 key-2 value table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable (cons (cons key-2 value) (cdr subtable)))))
        (set-cdr! table (cons (list key-1 (cons key-2 value)) (cdr table)))))
  'ok)
 #+end_src

*** Creating local tables

#+begin_src racket
#lang sicp

(define (make-table)
  (let ((local-table (list '*table*)))
    ;; define lookup procedure
    ;; define insert! procedure
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert!) insert!)
            (else (error "Unknown operation: TABLE"))))
    dispatch))

(define my-table (make-table))
(define get (my-table 'lookup))
(define put (my-table 'insert!))
#+end_src

*** Exercise 3.24

#+begin_src racket
#lang sicp

(define (make-table same-key?)

  (let ((local-table (list '*table*)))

    (define (assoc key records)
      (cond ((null? records) false)
            ((same-key? key (caar records) (car records)))
            (else (assoc (cdr records)))))
    ;; define lookup
    ;; define insert!
    ;; define dispatch

    ))

#+end_src

*** Exercise 3.25
*** Exercise 3.26
*** Exercise 3.27

- *Memoization/tabulation*: increase the performance of algorithms by storing previously calculated values

 #+begin_src racket
#lang sicp

(define (memoize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              result))))))

 #+end_src

** Simulator for Digital Circuits

- Writing an *event* driven simulator
- Objects which corresponds to components on a circuit

- Wire has value of 0 or 1
- Function boxes connect wires to output wires
- Output signal is time delayed depending on function box

- We are designing a "language" of circuits
  - language requires primitives, abstractions and combinations
  - we are just defining primitives
  - abstractions and combinations are inherited by Lisp
- "if a compound object does not look like a primitive, then there is something wrong with the language"

#+begin_src racket
#lang sicp

; want to represent wires like:
(define A (make-wire))
(define B (make-wire))

; want higher order structures like the following half-adder
(define (half-adder a b s c)
  (let ((d (make-wire)) (e (make-wire))) ; define internal wires
    (or-gate a b d)
    (and-gate a b c)
    (and-gate d e s)
    'ok))

;; can build even higher abstractions (e.g. full adder) on top of higher order structures as if they were primitives (e.g. half adder)

;; define primitive function that force change on wires
; (get-signal <wire>)
; (set-signal! <wire> <value>)
; (add-action! <wire> <procedure of no arguments>)

;; primitive digital logic
; inverter gate
(define (inverter input output)

  ; invert signal logic
  (define (logical-not s)
    (cond ((= s 0) 1)
          ((= s 1) 0)
          (else (error "Invalid signal: INVERTER" s))))

  (define (invert-input)
    ; let new-value be logical not of current value
    ; apply delay and set signal to new value
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay (lambda () (set-signal! output new-value))))
    ; apply action to let other signals know to change
    (add-action! input invert-input) 'ok))

; and gate
(define (and-gate a1 a2 output)

  ; and gate logic
  (define (logical-and s1 s2)
    (cond ((and (= s1 1) (= s2 1)) 1)
          ((or (= s1 0) (= s2 0)) 0)
          (else (error "Invalid signal: AND" s))))

  ; apply and gate action
  (define (and-action-procedure)
    (let ((new-value (logical-and (get-signal a1) (get-signal a2))))
      (after-delay and-gate-delay (lambda () (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)

  'ok)

; or gate
(define (or-gate a1 a2 output)

  ; or gate logic
  (define (logical-or s1 s2)
    (cond (or (= s1 1) (= s2 1) 1)
          (and (= s1 0) (= s2 0) 0)
          (else (error "Invalid signal: OR" s))))


  ; apply or gate action
  (define (or-action-procedure)
    (let ((new-value (logical-or (get-signal a1) (get-signal a2))))
      (after-delay or-gate-delay (lambda () (set-signal! output new-value)))))
  (add-action! a1 or-action-procedure)
  (add-action! a2 or-action-procedure)

  'ok)

(define (make-wire)
  (let ((signal-value 0))))

#+end_src

- How to simulate time delays
  - Use structure called an *agenda*: organizes time and actions
