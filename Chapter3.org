#+title: Chapter 3: Modularity, Objects and State
#+author: Joash Naidoo

- Really 2 prominent organizational strategies for programs:
  1. Concentrating on objects and how their behaviours change over time
    - Substitution model is not appropriate and will be replaced with *environment model* of computation
  2. Concentrating on streams like in signal processing systems
    - Will be discussing *delayed evaluation* model of computation

* Assignment and Local State

- Objects have a state if it changes over time
- Can alter the vale of the defined variable with *set!* (implementation dependant)
  - procedures which end with ! by convention change value of variable
- With *begin* keyword we can group and evaluate expressions part of a sequence

- Following code procedure shows how to create an "environment" for which only that procedure can modify the value of balance
- Substitution model of evaluation doesn't work here; i.e. can't substitute 100 for balance everytime as the code suggests
- Each call to make-withdraw defines procedures associated with balance. Dispatch takes a tag and returns corresponding method: *message-passing* programming

 #+begin_src racket
#lang sicp

; same as new-withdraw but now we set balance before-hand
(define (make-account balance)
  (define (widthdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount)) balance)
        "Insuffient funds"))

  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)

  (define (dispatch m)
    (cond ((eq? m 'widthdraw) widthdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown tag:" m))))

  dispatch) ; everytime make-account is called; call dispatch

(define W1 (make-account 100)) ; associating make-account procedure with variable W1
(define W2 (make-account 100))
((W1 'widthdraw) 3) ; calling make-account which in turn calls dispatch
((W2 'deposit) 50) ; calling make-account which in turn calls dispatch
 #+end_src

 #+RESULTS:
 : 97
 : 150

*** Exercise 3.1
#+begin_src racket
#lang sicp

(define (make-accumulator sum)
  (lambda (inc)
    (set! sum (+ sum inc))
    sum))

(define S1 (make-accumulator 10))
(define S2 (make-accumulator 10))
(S1 10)
(S1 10)
(S2 5)
#+end_src

#+RESULTS:
: 20
: 30
: 15

*** Exercise 3.2
#+begin_src racket
#lang sicp

(define (make-monitored func) ; procedure which takes function

  (let ((count 0)) ; set internal count variable

    (define (apply-procedure amount)
      (set! count (+ count 1)) ; inc everytime make-monitored called
      (func amount))

    (define (dispatch m)
      (cond ((eq? m 'how-many-calls?) count)
            ((eq? m 'reset) (begin (set! count 0) count))
            (else (apply-procedure m))))

    dispatch))

(define s (make-monitored sqrt))
(s 100)
(s 'how-many-calls?)
(s 100)
(s 'how-many-calls?)
(s 'reset)
#+end_src

#+RESULTS:
: 10
: 1
: 10
: 2
: 0

*** Exercise 3.3 and 3.4
#+begin_src racket
#lang sicp

(define (make-account balance password)

  (let ((incorrect-count 0))

    (define (widthdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insuffient funds"))

    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)

    (define (dispatch p m)
      (cond ((> incorrect-count 7) (error "Calling the cops"))
            ((not (eq? p password))
             (begin (set! incorrect-count (+ incorrect-count 1))
                    (error "Incorrect password")))
            ((eq? m 'widthdraw) widthdraw)
            ((eq? m 'deposit) deposit)
            (else (error "Unknown tag:" m))))

    dispatch))

(define acc (make-account 100 'secret-password))

((acc 'secret-password 'widthdraw) 40)
((acc 'secret-password 'deposit) 40)
((acc 'another-password 'deposit) 40)
#+end_src

** Benefits of assignment

- Viewing systems as objects with states can lead to modular design
- Great for modelling computational objects whose state changes over time

** Cost of Introducing assignment

- No longer use substitution model of evaluation
- No evaluation model with "nice" mathematical properties
- With assignments we cannot be sure a procedure with the same arguments to the same function will produce the same result
- Programming with no assignments is referred to as *functional* programming
- With state, variables are no longer just names for value

- Cannot determine "change" without some a priori notion of "sameness"

- Imperative programming: making extensive use of assignments
- Bugs susceptible to imperative programs and not functional ones:
  - Order of assignments becomes very important
  - This is worse when executing concurrent programs
- Imperative programs not more performant than calling procedures
- May be easier to start with functional programming over imperative; as being concerned with the order of assignments detract from important concepts

*** Exercise 3.7
#+begin_src racket
#lang sicp

#+end_src

*** Exercise 3.8
#+begin_src racket
#lang sicp

(define (make-function x)
        (lambda (y) (begin (set! x (* x y))
                           x)))

; order of evaluation of subexpressions matter with assigment
(define f (make-function -1))
(+ (f 0) (f 1))
(define s (make-function -1))
(+ (s 1) (s 0))
#+end_src

#+RESULTS:
: 0
: -1

* The Environment Model of Evaluation

- Environments are made up of a sequence of frames
- Frame: a table of *bindings* which associate variable names with values
  - each frame (except the global environment) has a pointer to enclosing environment. We can think of this as a stack of frames. If a variable name is not found in the current frame, move up frames until it is found
  - value of variable w.r.t environment is given by first frame in environment with a binding to that variable
  - if no frame has a binding to that variable; the variable is unbound
  - Top level frame is our *global environment*. It has no enclosing environments
  - frame may be shared across multiple environments

- Expressions are meaningless without respect to an environment. e.g (+ 1 1) the symbol + only means addition in an environment which defines addition (has an inherited context)

** Rules for evaluation

- Shift in viewpoint from substitution model:
  - variables not name for value but box in which we can store things
  - procedures not mathematical functions but object with inherited context

- Procedures created by evaluating a lambda expression (see. below)
- "define" creates definitions by adding bindings to frames
#+begin_src racket
(define (square x) (* x x))
; is the same as
(define square (lambda (x) (* x x)))
#+end_src
- A procedure created by lambda expression relative to a given environment. Resulting procedure consists of "double bubble" (i.e. code in lambda expression and pointer to environment in which it was created)

- Procedure is an object applied to set of arguments by constructing a frame
  Binding the formal parameters of the procedure to the arguments of the call

- Evaluating the body of the procedure results in the creation of a new environment (i.e. sequence of frames).

- The new frame has (points to) the enclosing environment of the environment for which procedure object is being applied


- "defining" symbol creates binding in current environment frame
- "set!" first locates the first frame with binding of the variable in the environment and changes binding to represent the new value
  - if variable unbound (i.e. no environment frame binding) it will throw an error

- We use this model for building an interpreter later

** Applying simple procedures
#+begin_src racket
#lang sicp

(define (square x) (* x x))
(define (sum-of-squares x y) (+ (square x) (square y)))
(define (f a) (sum-of-squares (+ a 1) (* a 2)))

;; global environment has bindings to lambda expressions square, sum-of-squares and f

(f 5)
;; evaluating a procedure creates new environment (e.g. E1) (points to global)
;; need to evaluate subexpressions
;; from E1 (no binding for sum-of-squares found) we move up to global environment
;; (+ a 1) and (* a 2) subexpression evaluated -> 6 and 10
;; applying 6 and 10 to proedure sum-of-squares results in new environment (e.g. E2) (points to global)
;; now evaluate subexpressions
;; find square in global frame
;; evaluate first square subexpression results in E3 (points to global)
;; evaluate second square subexpression results in E4 (points to global)
;; because we are setting up different environments for each procedure call; we can keep different bindings for variables names resued (e.g. x)
#+end_src

*** Exercise 3.9
#+begin_src racket
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))

;; global environment has bindings to lambda expression factorial
(factorial 6)
;; evaluate new procedure results in new environment E1
;;
#+end_src

- Replacing substitution model with environment model does not sort out issue of constant spacing. (That is addressed again in Chapter 5)
